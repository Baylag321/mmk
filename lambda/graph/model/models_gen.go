// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"lambda/lambda/graph/models"
	"strconv"
)

type PersonsInput struct {
	FirstName string `json:"FIRST_NAME"`
	LastName  string `json:"LAST_NAME"`
}

type Deleted struct {
	ID string `json:"id"`
}

type Filter struct {
	Column    string    `json:"column"`
	Condition Condition `json:"condition"`
	Value     string    `json:"value"`
}

type GroupFilter struct {
	Filters []*Filter `json:"filters"`
	Combine Combine   `json:"combine"`
}

type Paginate struct {
	Page        int                   `json:"page"`
	Total       int                   `json:"total"`
	LastPage    int                   `json:"last_page"`
	Persons     []*models.Persons     `json:"persons"`
	PersonItems []*models.PersonItems `json:"person_items"`
}

type Sort struct {
	Column string `json:"column"`
	Order  Order  `json:"order"`
}

type SubFilter struct {
	Column    string    `json:"column"`
	Table     string    `json:"table"`
	Condition Condition `json:"condition"`
	Value     string    `json:"value"`
}

type SubSort struct {
	Column string `json:"column"`
	Table  string `json:"table"`
	Order  Order  `json:"order"`
}

type SubTable struct {
	Table           string `json:"table"`
	ParentIdentity  string `json:"parentIdentity"`
	ConnectionField string `json:"ConnectionField"`
}

type Combine string

const (
	CombineOr  Combine = "or"
	CombineAnd Combine = "and"
)

var AllCombine = []Combine{
	CombineOr,
	CombineAnd,
}

func (e Combine) IsValid() bool {
	switch e {
	case CombineOr, CombineAnd:
		return true
	}
	return false
}

func (e Combine) String() string {
	return string(e)
}

func (e *Combine) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Combine(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid combine", str)
	}
	return nil
}

func (e Combine) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Condition string

const (
	ConditionEquals             Condition = "equals"
	ConditionNotEqual           Condition = "notEqual"
	ConditionContains           Condition = "contains"
	ConditionNotContains        Condition = "notContains"
	ConditionStartsWith         Condition = "startsWith"
	ConditionEndsWith           Condition = "endsWith"
	ConditionGreaterThan        Condition = "greaterThan"
	ConditionGreaterThanOrEqual Condition = "greaterThanOrEqual"
	ConditionLessThan           Condition = "lessThan"
	ConditionLessThanOrEqual    Condition = "lessThanOrEqual"
	ConditionIsNull             Condition = "isNull"
	ConditionNotNull            Condition = "notNull"
	ConditionWhereIn            Condition = "whereIn"
)

var AllCondition = []Condition{
	ConditionEquals,
	ConditionNotEqual,
	ConditionContains,
	ConditionNotContains,
	ConditionStartsWith,
	ConditionEndsWith,
	ConditionGreaterThan,
	ConditionGreaterThanOrEqual,
	ConditionLessThan,
	ConditionLessThanOrEqual,
	ConditionIsNull,
	ConditionNotNull,
	ConditionWhereIn,
}

func (e Condition) IsValid() bool {
	switch e {
	case ConditionEquals, ConditionNotEqual, ConditionContains, ConditionNotContains, ConditionStartsWith, ConditionEndsWith, ConditionGreaterThan, ConditionGreaterThanOrEqual, ConditionLessThan, ConditionLessThanOrEqual, ConditionIsNull, ConditionNotNull, ConditionWhereIn:
		return true
	}
	return false
}

func (e Condition) String() string {
	return string(e)
}

func (e *Condition) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Condition(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid condition", str)
	}
	return nil
}

func (e Condition) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Order string

const (
	OrderAsc  Order = "asc"
	OrderDesc Order = "desc"
)

var AllOrder = []Order{
	OrderAsc,
	OrderDesc,
}

func (e Order) IsValid() bool {
	switch e {
	case OrderAsc, OrderDesc:
		return true
	}
	return false
}

func (e Order) String() string {
	return string(e)
}

func (e *Order) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Order(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid order", str)
	}
	return nil
}

func (e Order) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

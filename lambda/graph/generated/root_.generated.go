// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"lambda/lambda/graph/model"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Mutation struct {
		CreatePersons func(childComplexity int, input model.PersonsInput) int
		DeletePersons func(childComplexity int, id string) int
		UpdatePersons func(childComplexity int, id string, input model.PersonsInput) int
	}

	PersonItems struct {
		ID              func(childComplexity int) int
		ItemDescription func(childComplexity int) int
		ItemName        func(childComplexity int) int
		PersonID        func(childComplexity int) int
	}

	Persons struct {
		CreatedAt   func(childComplexity int) int
		DeletedAt   func(childComplexity int) int
		FirstName   func(childComplexity int) int
		LastName    func(childComplexity int) int
		PersonID    func(childComplexity int) int
		PersonItems func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
	}

	Query struct {
		Paginate    func(childComplexity int, sorts []*model.Sort, groupFilters []*model.GroupFilter, filters []*model.Filter, subSorts []*model.SubSort, subFilters []*model.SubFilter, page int, size int) int
		PersonItems func(childComplexity int, sorts []*model.Sort, groupFilters []*model.GroupFilter, filters []*model.Filter, limit *int, offset *int) int
		Persons     func(childComplexity int, sorts []*model.Sort, groupFilters []*model.GroupFilter, filters []*model.Filter, subSorts []*model.SubSort, subFilters []*model.SubFilter, limit *int, offset *int) int
	}

	Deleted struct {
		ID func(childComplexity int) int
	}

	Paginate struct {
		LastPage    func(childComplexity int) int
		Page        func(childComplexity int) int
		PersonItems func(childComplexity int) int
		Persons     func(childComplexity int) int
		Total       func(childComplexity int) int
	}

	SubTable struct {
		ConnectionField func(childComplexity int) int
		ParentIdentity  func(childComplexity int) int
		Table           func(childComplexity int) int
	}
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "Mutation.createPersons":
		if e.complexity.Mutation.CreatePersons == nil {
			break
		}

		args, err := ec.field_Mutation_createPersons_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreatePersons(childComplexity, args["input"].(model.PersonsInput)), true

	case "Mutation.deletePersons":
		if e.complexity.Mutation.DeletePersons == nil {
			break
		}

		args, err := ec.field_Mutation_deletePersons_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeletePersons(childComplexity, args["id"].(string)), true

	case "Mutation.updatePersons":
		if e.complexity.Mutation.UpdatePersons == nil {
			break
		}

		args, err := ec.field_Mutation_updatePersons_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdatePersons(childComplexity, args["id"].(string), args["input"].(model.PersonsInput)), true

	case "PersonItems.ID":
		if e.complexity.PersonItems.ID == nil {
			break
		}

		return e.complexity.PersonItems.ID(childComplexity), true

	case "PersonItems.ITEM_DESCRIPTION":
		if e.complexity.PersonItems.ItemDescription == nil {
			break
		}

		return e.complexity.PersonItems.ItemDescription(childComplexity), true

	case "PersonItems.ITEM_NAME":
		if e.complexity.PersonItems.ItemName == nil {
			break
		}

		return e.complexity.PersonItems.ItemName(childComplexity), true

	case "PersonItems.PERSON_ID":
		if e.complexity.PersonItems.PersonID == nil {
			break
		}

		return e.complexity.PersonItems.PersonID(childComplexity), true

	case "Persons.CREATED_AT":
		if e.complexity.Persons.CreatedAt == nil {
			break
		}

		return e.complexity.Persons.CreatedAt(childComplexity), true

	case "Persons.DELETED_AT":
		if e.complexity.Persons.DeletedAt == nil {
			break
		}

		return e.complexity.Persons.DeletedAt(childComplexity), true

	case "Persons.FIRST_NAME":
		if e.complexity.Persons.FirstName == nil {
			break
		}

		return e.complexity.Persons.FirstName(childComplexity), true

	case "Persons.LAST_NAME":
		if e.complexity.Persons.LastName == nil {
			break
		}

		return e.complexity.Persons.LastName(childComplexity), true

	case "Persons.PERSON_ID":
		if e.complexity.Persons.PersonID == nil {
			break
		}

		return e.complexity.Persons.PersonID(childComplexity), true

	case "Persons.PERSON_ITEMS":
		if e.complexity.Persons.PersonItems == nil {
			break
		}

		return e.complexity.Persons.PersonItems(childComplexity), true

	case "Persons.UPDATED_AT":
		if e.complexity.Persons.UpdatedAt == nil {
			break
		}

		return e.complexity.Persons.UpdatedAt(childComplexity), true

	case "Query.paginate":
		if e.complexity.Query.Paginate == nil {
			break
		}

		args, err := ec.field_Query_paginate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Paginate(childComplexity, args["sorts"].([]*model.Sort), args["groupFilters"].([]*model.GroupFilter), args["filters"].([]*model.Filter), args["subSorts"].([]*model.SubSort), args["subFilters"].([]*model.SubFilter), args["page"].(int), args["size"].(int)), true

	case "Query.person_items":
		if e.complexity.Query.PersonItems == nil {
			break
		}

		args, err := ec.field_Query_person_items_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.PersonItems(childComplexity, args["sorts"].([]*model.Sort), args["groupFilters"].([]*model.GroupFilter), args["filters"].([]*model.Filter), args["limit"].(*int), args["offset"].(*int)), true

	case "Query.persons":
		if e.complexity.Query.Persons == nil {
			break
		}

		args, err := ec.field_Query_persons_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Persons(childComplexity, args["sorts"].([]*model.Sort), args["groupFilters"].([]*model.GroupFilter), args["filters"].([]*model.Filter), args["subSorts"].([]*model.SubSort), args["subFilters"].([]*model.SubFilter), args["limit"].(*int), args["offset"].(*int)), true

	case "deleted.id":
		if e.complexity.Deleted.ID == nil {
			break
		}

		return e.complexity.Deleted.ID(childComplexity), true

	case "paginate.last_page":
		if e.complexity.Paginate.LastPage == nil {
			break
		}

		return e.complexity.Paginate.LastPage(childComplexity), true

	case "paginate.page":
		if e.complexity.Paginate.Page == nil {
			break
		}

		return e.complexity.Paginate.Page(childComplexity), true

	case "paginate.person_items":
		if e.complexity.Paginate.PersonItems == nil {
			break
		}

		return e.complexity.Paginate.PersonItems(childComplexity), true

	case "paginate.persons":
		if e.complexity.Paginate.Persons == nil {
			break
		}

		return e.complexity.Paginate.Persons(childComplexity), true

	case "paginate.total":
		if e.complexity.Paginate.Total == nil {
			break
		}

		return e.complexity.Paginate.Total(childComplexity), true

	case "subTable.ConnectionField":
		if e.complexity.SubTable.ConnectionField == nil {
			break
		}

		return e.complexity.SubTable.ConnectionField(childComplexity), true

	case "subTable.parentIdentity":
		if e.complexity.SubTable.ParentIdentity == nil {
			break
		}

		return e.complexity.SubTable.ParentIdentity(childComplexity), true

	case "subTable.table":
		if e.complexity.SubTable.Table == nil {
			break
		}

		return e.complexity.SubTable.Table(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputPersonsInput,
		ec.unmarshalInputfilter,
		ec.unmarshalInputgroupFilter,
		ec.unmarshalInputsort,
		ec.unmarshalInputsubFilter,
		ec.unmarshalInputsubSort,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Query(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schemas-common/filter.graphql", Input: `input filter {
    column: String!
    condition:condition!
    value: String!
}
input groupFilter {
    filters:[filter]!
    combine: combine!
}
enum combine{
    or
    and
}
input subFilter {
    column: String!
    table: String!
    condition:condition!
    value: String!
}
enum condition{
    equals
    notEqual
    contains
    notContains
    startsWith
    endsWith
    greaterThan
    greaterThanOrEqual
    lessThan
    lessThanOrEqual
    isNull
    notNull
    whereIn
}

`, BuiltIn: false},
	{Name: "../schemas-common/mutation.graphql", Input: `type deleted {
    id:String!
}`, BuiltIn: false},
	{Name: "../schemas-common/scalar.graphql", Input: `scalar Time
scalar Date
scalar GormDeletedAt
`, BuiltIn: false},
	{Name: "../schemas-common/sort.graphql", Input: `input sort {
    column: String!
    order:order!
}
input subSort {
    column: String!
    table:String!
    order:order!

}
enum order{
    asc
    desc
}`, BuiltIn: false},
	{Name: "../schemas-common/sub.graphql", Input: `type subTable {
    table: String!
    parentIdentity:String!
    ConnectionField:String!
}`, BuiltIn: false},
	{Name: "../schemas/Personitems.graphql", Input: `type PersonItems  {
    ID: ID!
    ITEM_DESCRIPTION: String!
    ITEM_NAME: String!
    PERSON_ID: Int!   
} `, BuiltIn: false},
	{Name: "../schemas/Persons.graphql", Input: `type Persons  {
    CREATED_AT: Time!
    DELETED_AT: GormDeletedAt
    FIRST_NAME: String!
    LAST_NAME: String!
    PERSON_ID: ID!
    UPDATED_AT: Time!  
    PERSON_ITEMS:[PersonItems!] 
} `, BuiltIn: false},
	{Name: "../schemas/PersonsInput.graphql", Input: `input PersonsInput  {
    FIRST_NAME: String!
    LAST_NAME: String!   
} `, BuiltIn: false},
	{Name: "../schemas/mutations.graphql", Input: `type Mutation {
	
    "mutation-create"
    createPersons(input: PersonsInput!):Persons!
	
    "mutation-update"
    updatePersons(id: ID!, input:PersonsInput!):Persons!
    
    "mutation-delete"
    deletePersons(id: ID!):Persons!
}`, BuiltIn: false},
	{Name: "../schemas/schemas.graphql", Input: `type Query {
    persons(sorts:[sort], groupFilters:[groupFilter], filters:[filter], subSorts:[subSort], subFilters:[subFilter], limit: Int, offset: Int): [Persons!]
    person_items(sorts:[sort], groupFilters:[groupFilter], filters:[filter], limit: Int, offset: Int): [PersonItems!]
    paginate(sorts: [sort], groupFilters:[groupFilter], filters:[filter], subSorts:[subSort], subFilters:[subFilter], page:Int!, size:Int!): paginate!
}

type paginate  {
    page: Int!
    total: Int!
    last_page: Int!
    persons:[Persons!]
    person_items:[PersonItems!]
}


`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
